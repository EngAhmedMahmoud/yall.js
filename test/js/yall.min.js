var yall = (function () {
  'use strict';

  function yall (options) {
    options = options || {}; // Options

    var lazyClass = options.lazyClass || "lazy";
    var lazyBackgroundClass = options.lazyBackgroundClass || "lazy-bg";
    var idleLoadTimeout = "idleLoadTimeout" in options ? options.idleLoadTimeout : 200;
    var observeChanges = options.observeChanges || false;
    var events = options.events || {};
    var noPolyfill = options.noPolyfill || false; // Shorthands (saves more than a few bytes!)

    var win = window;
    var ric = "requestIdleCallback";
    var io = "IntersectionObserver"; // App stuff

    var dataAttrs = ["srcset", "src", "poster"];
    var arr = [];

    var queryDOM = function queryDOM(selector, root) {
      return arr.slice.call((root || document).querySelectorAll(selector || "img." + lazyClass + ",video." + lazyClass + ",iframe." + lazyClass + ",." + lazyBackgroundClass));
    }; // This function handles lazy loading of elements.


    var yallLoad = function yallLoad(element) {
      var parentNode = element.parentNode;

      if (parentNode.nodeName == "PICTURE") {
        yallApplyFn(queryDOM("source", parentNode), yallFlipDataAttrs);
      }

      if (element.nodeName == "VIDEO") {
        yallApplyFn(queryDOM("source", element), yallFlipDataAttrs);
      }

      yallFlipDataAttrs(element);

      if (element.autoplay) {
        element.load();
      }

      var classList = element.classList; // Lazy load CSS background images

      if (classList.contains(lazyBackgroundClass)) {
        classList.remove(lazyBackgroundClass);
        classList.add(options.lazyBackgroundLoaded || "lazy-bg-loaded");
      }
    };

    var yallBindEvents = function yallBindEvents(element) {
      for (var eventIndex in events) {
        element.addEventListener(eventIndex, events[eventIndex].listener || events[eventIndex], events[eventIndex].options || undefined);
      }
    }; // Added because there was a number of patterns like this peppered throughout
    // the code. This just flips necessary data- attrs on an element


    var yallFlipDataAttrs = function yallFlipDataAttrs(element) {
      var _loop = function _loop(dataAttrIndex) {
        if (dataAttrs[dataAttrIndex] in element.dataset) {
          win["requestAnimationFrame"](function () {
            element.setAttribute(dataAttrs[dataAttrIndex], element.dataset[dataAttrs[dataAttrIndex]]);

            if (element.nodeName === "SOURCE") {
              var videoOrPicture = element.parentNode;
              videoOrPicture.classList.remove(lazyClass);

              if (videoOrPicture.autoplay) {
                videoOrPicture.load();
              }
            }

            element.classList.remove(lazyClass);
          });
        }
      };

      for (var dataAttrIndex in dataAttrs) {
        _loop(dataAttrIndex);
      }
    }; // Noticed lots of loops where a function simply gets executed on every
    // member of an array. This abstraction eliminates that repetitive code.


    var yallApplyFn = function yallApplyFn(items, fn) {
      for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
        if (win[io] && fn instanceof win[io]) {
          fn.observe(items[itemIndex]);
        } else {
          fn(items[itemIndex]);
        }
      }
    };

    var yallIntersectionObserve = function yallIntersectionObserve(entry) {
      if (entry.isIntersecting || entry.intersectionRatio) {
        var element = entry.target;

        if (ric in win && idleLoadTimeout) {
          win[ric](function () {
            yallLoad(element);
          }, {
            timeout: idleLoadTimeout
          });
        } else {
          yallLoad(element);
        }

        intersectionListener.unobserve(element);
        lazyElements = lazyElements.filter(function (lazyElement) {
          return lazyElement != element;
        });

        if (!lazyElements.length && !observeChanges) {
          intersectionListener.disconnect();
        }
      }
    };

    var yallMutationObserve = function yallMutationObserve(newElement) {
      if (lazyElements.indexOf(newElement) < 0) {
        lazyElements.push(newElement);
        yallBindEvents(newElement);
        intersectionListener.observe(newElement);
      }
    };

    var yallCreateMutationObserver = function yallCreateMutationObserver(entry) {
      new MutationObserver(function () {
        yallApplyFn(queryDOM(), yallMutationObserve);
      }).observe(entry, options.mutationObserverOptions || {
        childList: true,
        subtree: true
      });
    };

    var lazyElements = queryDOM(); // If the current user agent is a known crawler, immediately load all media
    // for the elements yall is listening for and halt execution (good for SEO).

    if (/baidu|(?:google|bing|yandex|duckduck)bot/i.test(navigator.userAgent)) {
      yallApplyFn(lazyElements, yallLoad);
      return;
    }

    if (io in win && io + "Entry" in win) {
      var intersectionListener = new win[io](function (entries) {
        yallApplyFn(entries, yallIntersectionObserve);
      }, {
        rootMargin: ("threshold" in options ? options.threshold : 200) + "px 0%"
      });
      yallApplyFn(lazyElements, yallBindEvents);
      yallApplyFn(lazyElements, intersectionListener);

      if (observeChanges) {
        yallApplyFn(queryDOM(options.observeRootSelector || "body"), yallCreateMutationObserver);
      }
    } else {
      // IntersectionObserver not supported
      if (noPolyfill) {
        yallApplyFn(lazyElements, yallBindEvents);
        yallApplyFn(lazyElements, yallLoad);
      }
    }
  }

  return yall;

}());
